# Essential Concepts

## What is a Context?
At the core of the Contextual Scene Parser (CSP) lies contexts. Contexts serve as abstract descriptions of a certain chunk of code to be parsed. This tells the parser what each chunk of code is supposed to represent, and the rules associated with that context that the parser will follow when analyzing the code. Contexts are enclosed in parentheses *()*. Views will *always* inherit contexts (unless explicitly identified by the ruleset). 

## What is a Carriage?
A carriage tells the parser where the result from the code will return its value to. These are things like return statements, or the end results of comparison contexts *(where in a comparison context, the carriage at the end of the comparison will typically point back to the overarching view's carriage)*.
Carriages are enclosed in square brackets *[]*. Views by default always inherit the previous view index's statement _(i.e. an `if` statement with view index (*0,1,0) will inherit the carriage type from view index (*0,1))_. This behavior can be changed, however it's best to typically leave this alone unless defining things like pointers in C++ and Rust, where the output of a view needs to circumvent the viewbinder and interact with the binder directly.  
## What is a View Index?
A view index is a marker within the viewbinder stating where in the code chronologically the given view lies. Every view index is prefaced with an asterisk _(*)_, which represents the "file view" index. After that, the first number represents each view that is at the top level of the file, and each subsequent number represents a view within that top-level view. 

For example, an `if` statement within `fn main()` in a Rust program could have the view index _(*0,1)_, and its corresponding `else` statement would have view index _(*0,2)_. If the `if` statement had a nested `for` loop. the view index of that `for` loop would be _(*0,1,0)_. View indices always start at 0 for their order and count up. 

The previous view index relative to the current will always be referred to as `&`. 

## What is a "Scene"?
A scene is a synonym used to refer to a singular view, its viewbinder, and the general binder. 
## How these concepts interact
These three tools do the heavy lifting of the parser's job. New languages are integrated with the parser by building out JSON rulesets that use definitions of how a view is interpreted through its contexts, where the output of each view goes through its carriages, and where the view lies depending on its view index.

## Language Agnosticism 
This approach was created as a way to get around complicated text dissection methods typically used by other parsing techniques. Instead of reading text directly and giving a meaning to each interpreted word, the CSP breaks down code based on the predefined descriptions of the code. This creates a more language agnostic means of parsing code, as the parser isn't breaking apart multiple different languages in vastly different ways, it's instead creating abstractions of the code based on user definitions and breaking them into views, the viewbinder, and the binder. 

# Views, the Viewbinder, and the Binder 

## Views

Views are typically associated with rvalues and code blocks. A view can be thought of as a _"window into an action"_. A view can be something as simple as an assignment operation, or as complex as it needs to be thereafter. Let's remove the binder from a view to see what's going on.

<sub>Figure 1</sub>
<div style="flex: 1 0 auto;display: flex;flex-direction: column;border-left: 3px solid;border-bottom: 1px dashed;padding: 8px 8px;">
    <br />
    <p style="margin: auto;">[viewbinder] (condition)</p>
    <div id="conditional" 
    style="flex: 1 0 auto;display:flex;justify-content: space-around">
        <div style="flex: 0 1 auto;display: flex;flex-direction: column">
            <p style="margin: auto">[condition] (comparison) i < 0</p>
            <p style="margin: auto">↓</p>
            <p style="margin: auto;border-bottom: 1px dashed">(return) true</p>
        </div>
        <div style="flex: 0 1 auto;display: flex;flex-direction: column">
            <p style="margin: auto">[condition] (mirror) i >= 0</p>
            <p style="margin: auto">↓</p>
        <p style="margin: auto;border-bottom: 1px dashed">(return) false</p>
        </div>
    </div>
</div>

This contains a _"window"_ into a comparison operation and shows what value the 
view is going to send back to the viewbinder. 

This view is defined by default as having a mirror comparison that's generated by the parser automatically. The mirror uses an inverse operation of the main branch of the code. This is an example of an efficient parser rule, as the parser will be able to ultra-optimize code and detect errors easier. Now, instead, consider the following view:

<sub>Figure 2</sub>
<div style="flex: 1 0 auto;display: flex;flex-direction: column;border-left: 3px solid;border-bottom: 1px dashed;padding: 8px 8px;">
    <br />
    <p style="margin: auto;">[viewbinder] (condition)</p>
    <div id="conditional" 
    style="flex: 1 0 auto;display:flex;justify-content: space-around">
        <div style="flex: 0 1 auto;display: flex;flex-direction: column">
            <p style="margin: auto">[condition] (comparison) i < 0</p>
            <p style="margin: auto">↓</p>
            <p style="margin: auto;border-bottom: 1px dashed">(return) i</p>
        </div>
	</div>
</div>

The `(mirror)` context was removed as a requirement for `(condition)` contexts. Now the parser can't tell what the opposite result of the underlying code is. This won't generate any errors, and in this case it doesn't cause any problems with optimizations that can be made by the user, but in situations where each of the `(comparison)` views in Figure 1 branched off into multiple complex views, the parser would be able to suggest incredibly efficient optimizations to the receiving end of the parser by searching through each child view's contexts, carriages, results, and contained information.

## Viewbinder
On the left side of the figures above, notice the thicker solid line. This is the viewbinder. The viewbinder is responsible for moving output from a view back into the binder. 

# Rulesets
Rulesets are written in JSON format. 